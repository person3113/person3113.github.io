---
title: "[Oracle SQL 강의(뉴렉처)] 16 ~ 26강"
excerpt: "관계연산자 / 패턴 비교 연산자 / 정규식을 이용한 패턴 비교 / 행 제한하기 / DISTINCT / 문자열 함수 / 숫자 함수 / 날짜 함수"

categories:
  - Learning-DB
tags:
  - [Oracle, SQL]

toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"

date: 2023-01-12
last_modified_at: 2023-01-13
---

<br>

# [유튜브 강의 주소](https://www.youtube.com/watch?v=pGlkIFrY9QY&list=PLq8wAnVUcTFVq7RD1kuUwkdWabxvDGzfu)

<br>

# 보는 방법

- 강의가 화면 자료에 내용 설명이 적고, 적당히 설명해서 구체적으로 메모 힘들다. 따라서 키워드 위주로만 적었다.
- 강의 내용 복습은 메모한 것뿐만 아니라 강의 영상도 봐라.
- 여기서는 다음을 기록.
  - 강의 목차와 키워드 및 내용
  - 강의를 보고 생긴 의문에 대해 구글링해서 찾은 내용

<br><br>

# 16강 - 관계연산자(AND, OR, BETWEEN, IN)

## 강의 내용

- AND, BETWEEN
  - 조회수가 0,1,2인 게시글을 조회하시오
    - `SELECT * FROM NOTICE WHERE HIT>=0 AND HIT<=2;`
    - `SELECT * FROM NOTICE WHERE HIT BETWEEN 0 AND 2;`
- OR, IN
  - 조회수가 0,2,7인 게시글을 조회하시오
    - `SELECT * FROM NOTICE WHERE HIT=0 OR HIT=2 OR HIT=7;`
    - `SELECT * FROM NOTICE WHERE HIT IN(0, 2, 7);`
- NOT
  - 조회수가 0,2,7이 아닌 게시글을 조회하시오
  - `SELECT * FROM NOTICE WHERE HIT NOT IN(0, 2, 7);`

<br><br>

# 17강 - 패턴 비교 연산자(LIKE, %, `_` )

## 강의 내용

- 회원 중에서 박씨 성을 조회하시오
  - `SELECT * FROM MEMBER WHERE NAME LIKE '박%';`
  - LIKE 연산자: `SELECT FROM MEMBER WHERE NAME = '박%';`로 하면 실제로 이름이 '박%'인 사람만 조회하는 것임. 내가 원하는 건 박으로 시작하는 패턴이니까 이 때는 LIKE를 써야 함.
  - % 연산자: `WHERE NAME LIKE '박%'`의 뜻은 박으로 시작하는 이름을 필터링함.
- 회원 중에서 박씨이고 이름이 외자(한글자)인 회원을 조회하시오
  - `SELECT * FROM MEMBER WHERE NAME LIKE '박_';`
  - `-` 연산자: `WHERE NAME LIKE '박_'`의 뜻은 박으로 시작하는 이름을 필터링함. 단 글자 수 제한이 있음. 여기선 `박_`이니까 박제, 박사같은 이름만 검색될 것이고, `박__`이면 박일이, 박삼사같이 이름이 두 글자인 사람만 검색될 것임.
- 회원 중에서 박씨 성을 제외한 회원을 조회하시오
  - `SELECT * FROM MEMBER WHERE NAME NOT LIKE '박%';`
- 회원 중에서 이름에 '도'자가 들어간 회원을 조회하시오
  - `SELECT * FROM MEMBER WHERE NAME LIKE '%도%';`

<br><br>

# 18강 - 정규식을 이용한 패턴 비교(REGEXP_LIKE)

## 강의 내용

- 정규표현식 찾고 테스트할 수 있는 사이트: [Regular Expression Library](https://regexlib.com/?AspxAutoDetectCookieSupport=1)
- 아래 6개 패턴의 전화번호만 조회하고 싶을 때 정규표현식을 작성하기
  - 010-1234-1234, 011-342-6453, 016-543-1564, 017-522-1114, 018-543-1564,019-773-2264,
  - `^01[016-9]-\d{3,4}-\d{4}$`
    - ^와 $: 정규표현식에서 시작을 뜻하는 게 ^고, 끝을 나타내는 게 $이다.
    - 단 이렇게 하면 위의 전화번호 패턴만 있으면 찾을 수 있지만, "ASD 010-1234-1234 ASD"같이 섞여있으면 안된다. 왜냐면 ^가 있기 때문에 무조건 01[]로 시작하고, $가 있기 때문에 무조건 1234처럼 끝나야지만 찾을 수 있다. 따라서 이런 경우에는 ^와 $를 빼야 한다.
    - `01[016-9]`: []는 하나의 글자를 나타냄. 또 6-9의 뜻은 6에서 9까지란 의미(즉 6,7,8,9)이다. 따라서 `01[016-9]`의 뜻은 01로 시작하고 나머지 한 글자는 0이거나 1 또는 6 또는 6~9일 수 있따는 뜻.
    - \d{3,4}
      - \d는 decimal digit(a digit from 0 to 9 in decimal notation)이란 뜻으로, `[0-9]`와 동일하다.
      - {3,4}: 예로 ab{2}라 하면 abb가 된다. 즉 앞의 문자를 {}안에 지정한 숫자만큼 반복한다는 뜻이다. 따라서 \d{3,4}의 뜻은 \d\d\d 또는 \d\d\d\d를 뜻한다.
- REGEXP_LIKE
  - regular expression function이다.
  - 제목에 전화번호가 포함된 게시글을 조회하시오
    - (X) `SELECT * FROM NOTICE WHERE TITLE LIKE '01[016-9]-\d{3,4}-\d{4}';`: 오라클에서 제공하는 패턴 연산자(%나 `_`)가 아니고 정규표현식이기 때문에, LIKE를 쓸 수 없다.
    - (O) `SELECT * FROM NOTICE WHERE REGEXP_LIKE(TITLE, '01[016-9]-\d{3,4}-\d{4}');`

<br><br>

# 19강 - 문자열 비교를 위한 정규식(^\D\w+@...)

## 강의 내용

- 이메일을 정규표현식으로 표현. 단 끝은 org, net, com만 허용된다고 하자. 또한 123asd@123asd.com처럼 @ 앞뒤 단어의 시작이 숫자로 되면 안 된다고 하자.
  - `\D\w*@\D\w*.(org|net|com)`
    - `\D\w*`:
      - \D: Matches any nondigit. Equivalent to `[^0-9]`. 즉 0~9가 아닌 문자만 와야 하나만 와야 한다. @ 앞뒤 단어의 시작이 숫자로 되면 안 된다라는 조건이 있기 때문에 넣었다.
      - \w: Matches any word character. equivalent to `[a-zA-Z_0-9]`. 즉 소문자, 대문자, 언더바, 숫자를 포함하는 어떤 단어든 올 수 있다는 뜻이다.
      - `*`: 0 or more of previous expression. 즉 0개 이상이어야 한다는 뜻이다. `\w*`이란 뜻은 \w에 해당하는 문자가 0개 이상 와야한다는 뜻이다. 참고로 +는 1개 이상 와야한다는 뜻인데, \w+라 하면 \w에 해당하는 문자가 하나 이상 와야한다는 뜻이다. 이 때 \D를 해서 숫자가 아닌 문자를 하나 받았으므로 +가 아니라 `*`를 \w 뒤에다 썼다.
    - (org|net|com)
      - (): Logical grouping of part of an expression. 즉 이메일 끝 단어를 묶어준 것이다.
      - |: 단어를 구분해 주는 용도.

<br><br>

# 20강 - ROWNUM 그리고 행 제한하기

## 강의 내용

- 행 제한하기
  - 회원 목록에서 상위 5명만 조회하시오
    - ROWNUM: 이것은 SELECT해서 결과집합을 만들 때 만들어진다(간단히 말하면 SELECT할 때 만들어지는 번호). 즉 기존 테이블을 읽고 WHERE절에 해당하는 열을 결과집합에 넣을 때마다 1씩 증가하는 것이다. 따라서 `SELECT * FROM MEMBER WHERE ROWNUM BETWEEN 1 AND 5;`는 된다. 하지만 `SELECT * FROM MEMBER WHERE ROWNUM BETWEEN 6 AND 10;`은 빈 결과집합을 얻는다. ROWNUM은 무조건 1부터 자동으로 만들어지는데, 여기서 조건이 6부터 10이므로 모든 열이 해당되지 않아 아무것도 출력되지 않는다.
    - 그럼 ROWNUM이 결과집합 만들어질 때(즉 SELECT할 때) 생성되는 게 아니라 기존에 있었다면 가능할 것이다.
    - `SELECT * FROM (SELECT ROWNUM NUM, MEMBER.* FROM MEMBER) WHERE NUM BETWEEN 1 AND 5;`
      - `FROM (SELECT ROWNUM NUM, MEMBER.* FROM MEMBER)`: 먼저 MEMBER의 모든 컬럼(`MEMBER.*`)과 ROWNUM을 합쳐서 결과집합을 만든다. 이렇게 만든 결과집합에 대해 SELECT하겠다는 것이다.
      - `WHERE NUM BETWEEN 1 AND 5`: 앞에서 ROWNUM애 NUM이라는 별칭을 주었다. 이 별칭을 안 주고 `SELECT * FROM (~생략~) WHERE ROWNUM BETWEEN 6 AND 10;`처럼 했다면 WHERE의 ROWNUM은 기존의 ROWNUM(`FROM (SELECT ROWNUM, MEMBER.* FROM MEMBER)`해서 만들어진 ROWNUM)이 아니라, 새로 만들어지는 ROWNUM을 가리킨다. 따라서 아무것도 출력되지 않으므로, 이를 구분하기 위해서 별칭을 부여한 것이다.

<br><br>

# 21강 - 중복 값 제거하기 DISTINCT

## 강의 내용

- 중복 값 제거하기(DISTINCT)
  - 기존에 테이블에 19, 19, 19, 21, 23이 저장되어 있고, `SELECT AGE FROM MEMBER;`해서 저장된 값이 전부 나온다.
  - 하지만 이 때 종복되는 나이는 빼고 싶을 때, `SELECT DISTINCT AGE FROM MEMBER;`를 치면 결과로 19, 21, 23이 나온다. 즉 중복되는 나이 19가 빠진 것이다.

<br><br>

# 22강 - 중간요약과 함수 단원 안내

## 강의 내용

- 메모할 내용은 없었다.

<br><br>

# 23강 - 문자열 내장 함수 #1

## 강의 내용

- 문자열 추출 함수 SUBSTR 함수
  - SUBSTR(문자열, 시작위치, 길이)
    - SELECT SUBSTR('HELLO',1,3) FROM DUAL: 출력결과는 "HEL"
    - SELECT SUBSTR('HELLO',3) FROM DUAL: 출력결과는 "LLO"
    - SELECT SUBSTRB('HELLO',3) FROM DUAL: 출력결과는 "LLO"지만, 차이점은 1 BYTE단위로 끊는다.
    - SELECT SUBSTRB('안녕하신가',2) FROM DUAL: 출력결과는 "녕하신가"
    - SELECT SUBSTRB('안녕하신가',3) FROM DUAL: 출력결과는 "녕하신가"
  - 모든 회원의 이름과 출생 월만을 조회하시오(BIRTHDAY 형식: 2000-01-01)
    - SELECT NAME, SUBSTR(BIRTHDAY,6,2) MONTH FROM MEMBER
  - 회원 중에서 전화번호가 011로 시작하는 회원의 모든 정보를 조회하시오
    - `SELECT * FROM MEMBER WHERE SUBSTR(PHONE,1,3)='011'`: 이것도 되긴 하는데... 성능면으로 보면, 연산자가 조금 더 좋기 때문에, 연산자로만 해결 가능하면 함수 대신 연산자 쓰기
    - `SELECT * FROM MEMBER WHERE PHONE LIKE '011%'`
- 문자열 덧셈 함수
  - `SELECT CONCAT('홍','길동') FROM DUAL`
  - 단 덧셈 함수는 잘 안 쓰인다. `||` 연산자가 있기 때문이다.
  - `SELECT '홍'||'길동' FROM DUAL`
- 문자열 트림 함수: 공백 없애기
  - `SELECT LTRIM('   HELLO   ') FROM DUAL`: 왼쪽 공백만 없애기
  - `SELECT RTRIM('   HELLO   ') FROM DUAL`: 오른쪽 공백만 없애기
  - `SELECT TRIM('   HELLO   ') FROM DUAL`: 양쪽 공백 없애기
- 소문자/대문자 변경 함수
  - 주로 어디에 쓰는가? 회원의 아이디가 'NEWLEC'인 회원을 조회하되, 대소문자를 가리지 않을 때
    - `SELECT * FROM MEMBER WHERE UPPER(ID)='NEWLEC'`: 혹은 LOWER(ID)='newlec'이라고 해도 대소문자 가리지 않고 검색 가능
  - `SELECT LOWER('ASdf') FROM DUAL`: 다 소문자로
  - `SELECT UPPER('ASdf') FROM DUAL`: 다 대문자로
- 문자열 대치 함수 REPLACE와 TRANSLATE(문자열, 찾는 문자열, 대치할 문자열)
  - `SELECT REPLACE('WHERE WE ARE', 'WE', 'YOU') FROM DUAL`: 출력 결과 "WHERE YOU ARE". WE를 YOU로 대치하는 것
  - `SELECT TRANSLATE('WHERE WE ARE', 'WE', 'YOU') FROM DUAL`: 출력 결과 "YHORO YO ARO". W를 Y로 E를 O로 대치하는 것. U는 아무것도 대치되는 것이 없으므로 무효.
  - 회원의 주소를 빈칸없이 출력하기
  - `SELECT REPLACE(ADDRESS, ' ', '') FROM MEMBER;`

<br><br>

# 24강 - 문자열 내장 함수 #2

## 강의 내용

- 문자열 패딩 함수(채우는 함수)
  - `SELECT LPAD('HELLO', 10, '0') FROM DUAL`: 출력결과 "00000HELLO"
  - `SELECT RPAD('HELLO', 10, '0') FROM DUAL`: 출력결과 "HELLO00000"
- 문자열 검색 함수 INSTR
  - INSTR(문자열, 검색문자열, 찾을 시작위치, 찾을 수)
    - `SELECT INSTR('ALL WE NEED TO IS JUST TO...','TO') FROM DUAL`: 결과 13(TO의 위치)가 반환된다.
    - `SELECT INSTR('ALL WE NEED TO IS JUST TO...','TO',1,2) FROM DUAL`: 결과 24(TO의 위치)가 반환된다. 이 때 1의 뜻은 1번째 위치부터 찾으라는 소리고, 2의 뜻은 두 번째 TO의 위치를 뜻한다.
- 문자열 길이 얻기
  - `SELECT LENGTH('WHERE WE ARE') FROM DUAL`

<br><br>

# 25강 - 숫자 내장 함수(ABS/SIGN/ROUND/TRUNC/CEIL/FLOOR)

## 강의 내용

- 절댓값 ABS
  - SELECT ABS(-35) FROM DUAL;
  - 결과는 35
- 음수/양수 알려주는 SIGN
  - SELECT SIGN(-35) SIGN(35) SIGN(0)FROM DUAL;
  - 결과는 -1, 1, 0
- 반올림 ROUND
  - SELECT ROUND(34.56) ROUND(12.3456, 2) FROM DUAL;
  - 결과는 35, 12.35이다. ROUND(12.3456, 2)서 2의 뜻은 소수점 이하 2번째까지 출력해라는 소리
- TRUNC(절사 함수), MOD(나머지 연산)
  - SELECT 17/5 FROM DUAL: 결과는 3.4가 출력됨
  - SELECT TRUNC(17/5) FROM DUAL: 결과는 3이 출력됨
  - SELECT MOD(17,5) FROM DUAL: 결과는 2(나머지)가 출력됨
- 제곱 POWER, 제곱근 SQRT
  - SELECT POWER(5,2), SQRT(25) FROM DUAL: 결과는 25, 5이다.

<br><br>

# 26강 - 날짜 함수(`SYSDATE/CURRENT_DATE/SYSTIMESTAMP/CURRENT_...`)

## 강의 내용

- 현재 시간을 얻는 함수
  - SELECT SYSDATE, CURRENT_DATE, SYSTIMESTAMP, CURRENT_TIMESTAMP FROM DUAL
  - SYS는 오라클 서버 시간을, CURRENT는 사용자 시간을 나타낸다.
  - DATE는 년/월/일을, TIMESTAMP는 년/월/일에 시.분.초까지 나타냄
- 세션 시간과 포맷 변경
  - ALTER SESSION SET TIME_ZONE='09:00': 타임존은 나라마다 다르고, 자신이 있는 나라의 타임존으로 설정가능. 한국은 타임존이 09:00이다.
  - ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS': NLS는 NATIONAL LANGUAGE SUPPORT로 전세계 많은 언어에서 쓰이는 표기법을 지원하기 위해서인 느낌이 든다. 이렇게 설정하면 SYSDATE나 CURRENT_DATE을 출력해보면 정한 포멧으로 출력됨을 알 수 있다. 단 TIMESTAMP 계열은 해보니까 반영되지 않는 것 같다.
- 날짜 추출 함수 EXTRACT
  - SELECT EXTRACT(YEAR FROM SYSDATE) FROM DUAL: YEAR 대신 MONTH, DAY, MINUTE, SECOND 등이 올 수 있다.
  - 가입 회원 중에서 비수기(2,3,11,12월)에 가입한 회원을 조회하시오
    - `SELECT * FROM MEMBER WHERE EXTRACT(MONTH FROM REGDATE) IN (2,3,11,12)`
- 날짜 누적 함수 ADD_MONTHS(날짜, 정수)
  - SELECT ADD_MONTHS(SYSDATE, 1) FROM DUAL: 현재 13-JAN-2023일 때 결과는 13-FEB-23이 된다.
  - 회원 중 가입한지 6개월이 안 되는 회원을 조회하시오: `SELECT * FROM MEMBER WHERE ADD_MONTHS(SYSDATE,-6)<REGDATE`
- 날짜 차이 함수 MONTHS_BETWEEN(날짜, 날짜)
  - `SELECT MONTHS_BETWEEN(SYSDATE, REGDATE) FROM MEMBER`: 결과의 단위는 개월이다. 1.5라면 1.5개월, 0.7이면 한달이 안 되는 정도
  - 회원 중 가입한지 6개월이 안 되는 회원을 조회하시오: `SELECT * FROM MEMBER MONTHS_BETWEEN(SYSDATE, REGDATE)<6`
- 다음 요일을 알려주는 함수 NEXT_DAY(현재날짜, 다음요일)
  - SELECT NEXT_DAY(SYSDATE, '토') FROM DUAL: 여기서는 SYSDATE(현재 날짜)를 기준으로 바로 다음 토요일 날짜는 언제인지를 반환해줌
- 월의 마지막 일자를 알려주는 함수 LAST_DAY(날짜)
  - SELECT LAST_DAY(SYSDATE) FROM DUAL: 만약 SYSDATE가 2023-1-13이라면 출력은 31-JAN-23이 나온다.
- 지정된 범위에서 날짜를 반올림하는/자르는 함수 ROUND/TRUNC(날짜, 포멧)
  - 자세한 건 필요할 때 찾아 보기
